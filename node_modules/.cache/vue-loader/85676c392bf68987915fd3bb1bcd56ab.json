{"remainingRequest":"/Users/wangzhigang/Desktop/styd/web/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/wangzhigang/Desktop/styd/web/src/views/biz-components/date-slider/button.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/wangzhigang/Desktop/styd/web/src/views/biz-components/date-slider/button.vue","mtime":1591147717102},{"path":"/Users/wangzhigang/Desktop/styd/web/node_modules/cache-loader/dist/cjs.js","mtime":1591062571898},{"path":"/Users/wangzhigang/Desktop/styd/web/node_modules/babel-loader/lib/index.js","mtime":1591062567418},{"path":"/Users/wangzhigang/Desktop/styd/web/node_modules/cache-loader/dist/cjs.js","mtime":1591062571898},{"path":"/Users/wangzhigang/Desktop/styd/web/node_modules/vue-loader/lib/index.js","mtime":1591062572376}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nexport default {\n  name: 'StSliderButton',\n  bem: {\n    sliderButton: 'st-slider-button'\n  },\n  props: {\n    value: {\n      type: Number,\n      default: 0\n    }\n  },\n  data() {\n    return {\n      dragging: false,\n      isClick: false,\n      startX: 0,\n      currentX: 0,\n      startPosition: 0,\n      newPosition: null,\n      oldValue: this.value\n    }\n  },\n  computed: {\n    wrapperStyle() {\n      return { left: this.currentPosition }\n    },\n    max() {\n      return this.$parent.max\n    },\n    min() {\n      return this.$parent.min\n    },\n    rangeFirst() {\n      return this.$parent.rangeFirst\n    },\n    rangeSecond() {\n      return this.$parent.rangeSecond\n    },\n    range() {\n      return this.$parent.range\n    },\n    step() {\n      return this.$parent.step\n    },\n    precision() {\n      return this.$parent.precision\n    },\n    disable() {\n      return this.$parent.disable\n    },\n    currentPosition() {\n      return `${((this.value - this.min) / (this.max - this.min)) * 100}%`\n    },\n    enableFormat() {\n      // tipFormatter\n      return this.$parent.tipFormatter instanceof Function\n    },\n    formatValue() {\n      // 格式化后的tips数据\n      return (\n        (this.enableFormat && this.$parent.tipFormatter(this.value)) ||\n        this.value\n      )\n    }\n  },\n  watch: {\n    dragging(val) {\n      this.$parent.dragging = val\n    }\n  },\n  mounted() {},\n  methods: {\n    onMouseDown(event) {\n      if (this.disable) {\n        event.preventDefault()\n      }\n      this.onDragStart(event)\n      window.addEventListener('mousemove', this.onDragging)\n      window.addEventListener('mouseup', this.onDragEnd)\n      window.addEventListener('contextmenu', this.onDragEnd) // 右键点击时 进行\n    },\n    onDragging() {\n      if (!this.disable && this.dragging) {\n        this.isClick = false\n        this.$parent.resetSize()\n        let diff = 0\n        this.currentX = event.clientX\n        diff = ((this.currentX - this.startX) / this.$parent.sliderSize) * 100\n        this.newPosition = this.startPosition + diff\n        this.setPosition(this.newPosition)\n      }\n    },\n    onDragStart(event) {\n      if (this.disable) return\n      this.dragging = true\n      this.isClick = true\n      this.startX = event.clientX\n      this.startPosition = parseFloat(this.currentPosition)\n      this.newPosition = this.startPosition\n    },\n    onDragEnd() {\n      if (!this.disable && this.dragging) {\n        setTimeout(() => {\n          this.dragging = false\n          if (!this.isClick) {\n            this.setPosition(this.newPosition)\n            this.$parent.emitChange()\n          }\n        }, 0)\n        window.removeEventListener('mousemove', this.onDragging)\n        window.removeEventListener('mouseup', this.onDragEnd)\n        window.removeEventListener('contextmenu', this.onDragEnd)\n      }\n    },\n    setPosition(newPosition) {\n      if (newPosition === null || isNaN(newPosition)) return\n      if (newPosition < 0) {\n        newPosition = 0\n      } else if (newPosition > 100) {\n        newPosition = 100\n      }\n      const lengthPerStep = 100 / ((this.max - this.min) / this.step)\n      const steps = Math.round(newPosition / lengthPerStep)\n      let value =\n        steps * lengthPerStep * (this.max - this.min) * 0.01 + this.min\n      value = parseFloat(value.toFixed(this.precision))\n      this.$emit('input', value)\n      if (!this.dragging && this.value !== this.oldValue) {\n        this.oldValue = this.value\n      }\n    }\n  },\n  beforeDestroy() {\n    window.removeEventListener('mousemove', this.onDragging)\n    window.removeEventListener('mouseup', this.onDragEnd)\n    window.removeEventListener('contextmenu', this.onDragEnd)\n  }\n}\n",{"version":3,"sources":["button.vue"],"names":[],"mappings":";;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"button.vue","sourceRoot":"src/views/biz-components/date-slider","sourcesContent":["<template>\n  <div\n    :class=\"sliderButton()\"\n    :style=\"wrapperStyle\"\n    ref=\"button\"\n    @mousedown=\"onMouseDown\"\n  >\n    <div :class=\"sliderButton('toolTip')\">{{ formatValue }}</div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'StSliderButton',\n  bem: {\n    sliderButton: 'st-slider-button'\n  },\n  props: {\n    value: {\n      type: Number,\n      default: 0\n    }\n  },\n  data() {\n    return {\n      dragging: false,\n      isClick: false,\n      startX: 0,\n      currentX: 0,\n      startPosition: 0,\n      newPosition: null,\n      oldValue: this.value\n    }\n  },\n  computed: {\n    wrapperStyle() {\n      return { left: this.currentPosition }\n    },\n    max() {\n      return this.$parent.max\n    },\n    min() {\n      return this.$parent.min\n    },\n    rangeFirst() {\n      return this.$parent.rangeFirst\n    },\n    rangeSecond() {\n      return this.$parent.rangeSecond\n    },\n    range() {\n      return this.$parent.range\n    },\n    step() {\n      return this.$parent.step\n    },\n    precision() {\n      return this.$parent.precision\n    },\n    disable() {\n      return this.$parent.disable\n    },\n    currentPosition() {\n      return `${((this.value - this.min) / (this.max - this.min)) * 100}%`\n    },\n    enableFormat() {\n      // tipFormatter\n      return this.$parent.tipFormatter instanceof Function\n    },\n    formatValue() {\n      // 格式化后的tips数据\n      return (\n        (this.enableFormat && this.$parent.tipFormatter(this.value)) ||\n        this.value\n      )\n    }\n  },\n  watch: {\n    dragging(val) {\n      this.$parent.dragging = val\n    }\n  },\n  mounted() {},\n  methods: {\n    onMouseDown(event) {\n      if (this.disable) {\n        event.preventDefault()\n      }\n      this.onDragStart(event)\n      window.addEventListener('mousemove', this.onDragging)\n      window.addEventListener('mouseup', this.onDragEnd)\n      window.addEventListener('contextmenu', this.onDragEnd) // 右键点击时 进行\n    },\n    onDragging() {\n      if (!this.disable && this.dragging) {\n        this.isClick = false\n        this.$parent.resetSize()\n        let diff = 0\n        this.currentX = event.clientX\n        diff = ((this.currentX - this.startX) / this.$parent.sliderSize) * 100\n        this.newPosition = this.startPosition + diff\n        this.setPosition(this.newPosition)\n      }\n    },\n    onDragStart(event) {\n      if (this.disable) return\n      this.dragging = true\n      this.isClick = true\n      this.startX = event.clientX\n      this.startPosition = parseFloat(this.currentPosition)\n      this.newPosition = this.startPosition\n    },\n    onDragEnd() {\n      if (!this.disable && this.dragging) {\n        setTimeout(() => {\n          this.dragging = false\n          if (!this.isClick) {\n            this.setPosition(this.newPosition)\n            this.$parent.emitChange()\n          }\n        }, 0)\n        window.removeEventListener('mousemove', this.onDragging)\n        window.removeEventListener('mouseup', this.onDragEnd)\n        window.removeEventListener('contextmenu', this.onDragEnd)\n      }\n    },\n    setPosition(newPosition) {\n      if (newPosition === null || isNaN(newPosition)) return\n      if (newPosition < 0) {\n        newPosition = 0\n      } else if (newPosition > 100) {\n        newPosition = 100\n      }\n      const lengthPerStep = 100 / ((this.max - this.min) / this.step)\n      const steps = Math.round(newPosition / lengthPerStep)\n      let value =\n        steps * lengthPerStep * (this.max - this.min) * 0.01 + this.min\n      value = parseFloat(value.toFixed(this.precision))\n      this.$emit('input', value)\n      if (!this.dragging && this.value !== this.oldValue) {\n        this.oldValue = this.value\n      }\n    }\n  },\n  beforeDestroy() {\n    window.removeEventListener('mousemove', this.onDragging)\n    window.removeEventListener('mouseup', this.onDragEnd)\n    window.removeEventListener('contextmenu', this.onDragEnd)\n  }\n}\n</script>\n"]}]}