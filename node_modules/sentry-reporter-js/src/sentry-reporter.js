import qs from 'qs'
import Raven from 'raven-js'
import RavenVue from './raven-vue'

class ResourceError extends Error {
  constructor({ tagName = '', url = '' } = {}) {
    super(`${url}`)
    this.name = `ResourceError [${tagName}]`
  }
}

class HttpError extends Error {
  constructor({ status = 0, method = 'GET', url = '' } = {}) {
    super(`${url}`)
    this.name = `HttpError [${method} ${status}]`
  }
}

const SentryReporter = {
  init({
    dsn = '',
    ignoreErrors = [],
    debug = false,
    enable = true,
    release = '',
    environment = '',
    framework = {},
    resourceError = {
      level: 'warning'
    },
    httpError = {
      level: 'warning'
    },
    allowDuplicates = false
  } = {}) {
    this.debug = debug
    this.enable = enable
    this.environment = environment
    this.dsn = dsn
    this.ignoreErrors = ignoreErrors
    this.release = release
    this.framework = framework
    this.allowDuplicates = allowDuplicates

    this.resourceErrorCaptureTagName = (
      resourceError.captureTagName || ['img', 'audio', 'video', 'link']
    ).map(tag => tag.toUpperCase())
    this.resourceErrorLevel = resourceError.level || 'warning'
    this.httpErrorLevel = httpError.level || 'warning'
    this.httpResponseHeaderTags = httpError.responseHeaderTags || []
    if (this.debug) {
      console.log('[SentryReporter] in debug mode')
    }
    if (this.enable || this.debug) {
      this._config()
      this._setFramework()
      this._install()
    }
    return this
  },
  _config() {
    const _this = this
    Raven.config(this.dsn, {
      release: this.release,
      ignoreErrors: this.ignoreErrors,
      environment: this.environment,
      allowDuplicates: this.allowDuplicates,
      dataCallback(data) {
        if (data && data.breadcrumbs && data.breadcrumbs.values) {
          const _sendCrumbs = []
          data.breadcrumbs.values.forEach(crumb => {
            if (crumb.category.indexOf('$ui') > -1) {
              _sendCrumbs.pop()
            }
            _sendCrumbs.push(crumb)
          })
          data.breadcrumbs.values = _sendCrumbs
        }
        data.extra = data.extra || {}
        data.extra.page_title = document.title
        data.extra.page_url = location.href

        return data
      },
      shouldSendCallback(data) {
        if (_this.debug) {
          console.log('[sentry-reporter] sendData -> ', data)
          return false
        }
        return true
      }
    })
    var old_captureException = Raven.captureException
    Raven.captureException = function(ex, options) {
      if (ex && ex.noReport) {
        return
      }
      old_captureException.apply(Raven, arguments)
    }
  },
  _setFramework() {
    if (Object.keys(this.framework).length && (this.enable || this.debug)) {
      if (this.framework.Vue) {
        this._setVue(this.framework.Vue)
      }
    }
  },
  _setVue(Vue) {
    const _oldHandler = Vue.config.errorHandler
    Vue.config.errorHandler = function(error) {
      if (!_oldHandler) {
        console.error(error)
      }
      _oldHandler && _oldHandler.apply(null, arguments)
    }
    Raven.addPlugin(RavenVue, Vue)
  },
  _install() {
    Raven.install()
    this._globalKey = Raven._globalKey
    // we don't care ie
    if (window.addEventListener) {
      this._bindEventListener()
      this._bindResourceError()
      this._bindXhr()
      this._bindOnlineStatus()
    }
  },
  _bindOnlineStatus() {
    window.addEventListener('offline', () => {
      Raven.captureBreadcrumb({
        category: 'network.offline',
        message: 'browser is offline',
        level: 'warning'
      })
    })
    window.addEventListener('online', () => {
      Raven.captureBreadcrumb({
        category: 'network.online',
        message: 'browser is online',
        level: 'info'
      })
    })
  },
  _bindEventListener() {
    const oldListener = Element.prototype.addEventListener
    Element.prototype.addEventListener = function proxyEventListener(
      eventName,
      eventHandler,
      shouldBuble
    ) {
      // only proxy click handler
      if (eventName === 'click') {
        oldListener.call(
          this,
          eventName,
          function ravenHandlerProxy(e, ...rest) {
            Raven.captureBreadcrumb({
              category: '$ui.' + eventName,
              message: e.target.outerHTML,
              data: {}
            })
            eventHandler.call(this, e, ...rest)
          },
          shouldBuble
        )
      } else {
        oldListener.apply(this, arguments)
      }
    }
  },
  _bindXhr() {
    this._bindXhrOpen()
    this._bindXhrSetRequestHeader()
    this._bindXhrSend()
  },
  _bindXhrOpen() {
    const _oldOpen = XMLHttpRequest.prototype.open
    XMLHttpRequest.prototype.open = function(method, url) {
      const urlArr = url.split('?')
      this.__sentry_reporter_xhr__ = {
        headers: {},
        method,
        url,
        pathUrl: urlArr[0],
        params: qs.parse(urlArr[1] || ''),
        body: ''
      }
      return _oldOpen.apply(this, arguments)
    }
  },
  _bindXhrSetRequestHeader() {
    const _oldSetHeader = XMLHttpRequest.prototype.setRequestHeader
    XMLHttpRequest.prototype.setRequestHeader = function(
      headerName,
      headerValue
    ) {
      this.__sentry_reporter_xhr__.headers[headerName] = headerValue
      return _oldSetHeader.apply(this, arguments)
    }
  },
  _bindXhrSend() {
    const _this = this
    function _handleEvent(ev) {
      // ev.target is the xhr instance
      if (ev && ev.target && ev.target.status !== 200 && ev.type !== 'abort') {
        const thisXhr = ev.target
        const {
          method,
          url,
          body,
          params,
          headers,
          pathUrl
        } = thisXhr.__sentry_reporter_xhr__
        let body_parsed = body
        if (
          headers['Content-Type'] &&
          headers['Content-Type'].indexOf('form-urlencoded') > -1
        ) {
          body_parsed = qs.parse(body)
        } else {
          try {
            body_parsed = JSON.parse(body)
          } catch (e) {}
        }
        const Request = {
          url,
          method,
          params,
          headers,
          pathUrl,
          body,
          body_parsed
        }

        const Response = {
          status: thisXhr.status,
          statusText: thisXhr.statusText,
          response: thisXhr.response,
          headers: thisXhr.getAllResponseHeaders()
        }
        const fingerprint = [Request.method, Response.status]

        if (url.indexOf(_this._globalKey) === -1) {
          let headerTags = {}
          _this.httpResponseHeaderTags.forEach(item => {
            item = item.toLowerCase()
            headerTags[item] = thisXhr.getResponseHeader(item)
          })
          Raven.captureException(
            new HttpError({
              status: Response.status,
              url: Request.url,
              method: Request.method
            }),
            {
              level: _this.httpErrorLevel,
              fingerprint,
              tags: Object.assign(
                {
                  request_url: Request.url
                },
                headerTags
              ),
              extra: {
                fingerprint,
                Request,
                Response
              }
            }
          )
        }
      }
    }

    const _oldSend = XMLHttpRequest.prototype.send
    XMLHttpRequest.prototype.send = function(body) {
      this.__sentry_reporter_xhr__.body = body
      if (this.addEventListener) {
        this.addEventListener('error', _handleEvent)
        this.addEventListener('load', _handleEvent)
        this.addEventListener('abort', _handleEvent)
      } else {
        const _oldStateChange = this.onreadystatechange
        this.onreadystatechange = function(ev) {
          if (this.readyState === 4) {
            _handleEvent(ev)
          }
          _oldStateChange && _oldStateChange.apply(this, arguments)
        }
      }
      return _oldSend.apply(this, arguments)
    }
  },
  _bindResourceError() {
    const _this = this
    window.addEventListener(
      'error',
      function(e) {
        const el = e.target
        // 判断是非 js 运行时错误
        if (!e.message) {
          const resourceUrl = el.href || el.src
          const resource = {
            outerHTML: el.outerHTML,
            tagName: el.tagName,
            url: resourceUrl,
            pathUrl: resourceUrl.split('?')[0]
          }

          const fingerprint = [resource.tagName]

          if (
            _this.resourceErrorCaptureTagName.indexOf(resource.tagName) > -1
          ) {
            Raven.captureException(
              new ResourceError({
                url: resource.url,
                tagName: resource.tagName
              }),
              {
                level: _this.resourceErrorLevel,
                fingerprint,
                tags: {
                  resource_url: resource.url
                },
                extra: {
                  resource,
                  fingerprint
                }
              }
            )
          } else {
            Raven.captureBreadcrumb({
              category: `resource.error`,
              message: `${resource.outerHTML}`,
              level: _this.resourceErrorLevel
            })
          }
        }
      },
      true
    )
  },
  setFramework(framework = {}) {
    this.framework = framework
    this._setFramework()
    return this
  },
  setUserContext(...args) {
    Raven.setUserContext(...args)
    return this
  },
  setTagsContext(...args) {
    Raven.setTagsContext(...args)
    return this
  },
  setExtraContext(...args) {
    Raven.setExtraContext(...args)
    return this
  },
  captureException(...args) {
    Raven.captureException(...args)
    return this
  },
  captureBreadcrumb(...args) {
    Raven.captureBreadcrumb(...args)
    return this
  },
  captureMessage(...args) {
    Raven.captureMessage(...args)
    return this
  }
}

export default SentryReporter
